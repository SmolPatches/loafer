#+title: Loafer Research
* Loafer Notes
**TODO
- Lexical Analyzer for HTTP Parsing(Rest Server)
- Refactor Crate to have:
  - Separate Binaries
  - A library
  - Example binaries of how to use the library
- Finish Type State Validation
  - Request::Get struct variant
  - Request::Post
  - Rest of HTTP Options
- Look @ good http parsers in go / other languages and see how they do it(get inspired)
** Scope
Build Socket to Connect To MPV IPC
IPC should exposed
- Skip / Forward
- Add to queue of videos
HTML frontend
- To skip / control
- Add videos to queue and control playback
** MPV architecture
*** Embeddable C API
C API that control over playback (libmpv)
[[https://github.com/mpv-player/mpv/blob/master/libmpv/client.h]]
Rust Bindings Option is Available with  [[https://crates.io/crates/libmpv][libmpv-rs]]
*** C Plugins
[[https://mpv.io/manual/master/#c-plugins][here]]
Not really sure how this differs from libmpv, apparently it uses libmpv
Potential use case for Zig here if C Plugin route is taken
I can also write rust code to compile to .so file here and be used as a plugin
*** Lua / JS Scripting API
I believe these use libmpv as the backend so I could just use that instead
* HTTP Server
Loafer needs an rest server and a frontend/ui to trigger ipc events.
Simplest approach is a website hosted on an http server with an API endpoint(currently also http)
*** HTTP Parsing
The **REST** server needs to parse HTTP data to make sure this is valid
The approach I am taking is using a buffer reader to read lines
But this made me realize the actual lines need to be parsed, raising concerns
- regex is hacky and shameful
- string functions is morally wrong
So is the only solution lexical analysis?
2 Solutions are Lexical Analysis and State Machines
Look @ some http crates to see how they do it
- Nom, [[https://docs.rs/nom/latest/nom/#]]
Chatgpt Notes
#+BEGIN_VERSE
States:
1. Method State
2. URI State
3. Version State
4. End State (Complete parsing)

Transitions:
- Initial State: Method State
- Method State:
  - Transition to URI State upon encountering a whitespace character
- URI State:
  - Transition to Version State upon encountering a whitespace character
- Version State:
  - Transition to End State upon encountering '\r\n' (end of line)
- End State: Parsing complete

Actions:
- Accumulate characters for method, URI, and version fields
- Validate and process the parsed HTTP request line
State Machine
            +--------+     whitespace      +--------+
            | Method |-------------------> |   URI  |
            +--------+                     +--------+
                ^                              |
                |                              |
                |     whitespace               |
                +------------------------------+
                |
                v
            +--------+
            | Version|
            +--------+
                |
                |
                v
            +--------+
            |  End   |
            +--------+

#+END_VERSE
